\section{Quantitative congruence closure}

Given a conjunction $\Psi$ of propositions, the quantitative congruence closure infers all equalities that are logically implied by $\Psi$.
As there are infinitely many such equalities, we consider only the equalities that contain terms from a specific set $\T$ of terms.
The set $\T$ must be subterm-closed and contain at least all the terms that occur in $\Psi$.
The equalities implied by $\Psi$ are described by the quantitative equivalence relation $\equivp$,
which is the smallest equivalence relation $\equivp$ that satisfies these rules:
\begin{enumerate}[label={[E\arabic*]}, ref={[E\arabic*]}]
  \setcounter{enumi}{-1}
\item\label{item:persistence} If $t_1 = z+t_2$ occurs in $\Psi$, then $t_1 \equivp z+t_2$;
\item\label{item:quantitative-reflexivity} $t_1 \equivp 0+t_1$ for all $t\in\T$(\emph{quantitative reflexivity});
\item\label{item:quantitative-symmetry} If $t_1 \equivp z+t_2$, then $t_2 \equivp -z+t_1$ (\emph{quantitative symmetry});
\item\label{item:quantitative-transitivity} If $t_1 \equivp z_1+t_2$ and $t_2 \equivp z_2 + t_3$,
		then $t_1 \equivp (z_1+z_2)+t_3$ (\emph{quantitative transitivity});
\item\label{item:dereferencing} If $t_1 \equivp (z_2 - z_1) + t_2$, then $*(z_1 + t_1) \equivp *(z_2 + t_2)$ holds as well, whenever $*(z_1 + t_1),  *(z_2 + t_2)$ are in $\T$ (\emph{dereferencing}).
\end{enumerate}

\subsection{Quantitative union-find}

We can represent the quantitative equivalence relation $\equivp$ by using a data structure similar to union-find, but extended with integer offsets.
The \emph{quantitative union-find} $(\Pi, \tau, \omega)$ consists of a partition $\Pi$ of $\T$,
a function $\tau : \Pi \rightarrow \T$ that assigns a representative term to each equivalence class $Q \in \Pi$ and a mapping $\omega : \T \rightarrow \Z$,
which assigns to each term its offset from the representative of its equivalence class.
A set $Q \in \Pi$ contains all terms that are equivalent up to an integer offset.

There exist efficient algorithms for the union-find data structure,
in particular the well-known representation proposed by~\textcite{uf-tarjan},
which we will present in this section.
We extend this approach to handle integer offsets as well.

The union-find partition is represented as an acyclic directed weighted graph,
where each node represents a term $t \in \T$ and
each connected component is a tree, which represents an equivalence class $Q \in \Pi$.
Each tree has a root, that is the representative $\tau Q$ of the equivalence class $Q$.
All the edges in the tree are directed towards the root.
Each edge from $t_1$ to $t_2$ is weighted with an integer $z$,
which means that $t_1 \equivp z + t_2$.
$\omega t$ can be computed by following the path from $t$ to the root of the tree and summing up the weights of the edges.
The \find{t} operation returns the pair $(\otau\,t, \omega\,t)$ for a given term $t$,
where $\otau\,t$ denotes the representative $\tau\,Q$ of the equivalence class $Q\in\Pi$ that contains $t$.

The union-find data structure is initialized with a partition $\Pi$ that contains all the terms from $\T$ as singletons.
The corresponding graph contains a node for each $t \in \T$ and no edges.
Then for each equality $t_1 = z + t_2$ in $\Psi$, we perform the \union{t_1}{t_2}{z} operation, which merges two trees by adding an edge from $\tau\,t_1$ to $\tau\,t_2$ with weight $z - \omega\,t_1 + \omega\,t_2$.

\begin{example}
Consider the conjunction $\Psi \equiv B = 1 + A \land D = 2 + \&x \land A = 3 + \&x$.
The union-find algorithm computes the following tree after having performed the three union operations:

\begin{tikzpicture}[->, node distance=2cm, auto]
    \node (x) {$\&x$};
    \node (A) [below left of=x] {$A$};
    \node (D) [below right of=x] {$D$};
    \node (B) [below=1cm of A] {$B$};

    \path (A) edge node {3} (x);
    \path (B) edge node {1} (A);
    \path (D) edge node {2} (x);
\end{tikzpicture}

From this representation, we can for example derive that $B = 4 + \&x$.

Depending on the choice of the representatives, the tree can look different.
In a practical implementation, the representatives are chosen in such a way that the trees have the lowest possible height,
thus making the \find{t} operation more efficient.
Another possible optimization is to set the parent node of a term to the representative of the tree,
each time the \find{t} operation is called.
This way, the tree is flattened, which makes the \find{t} operation
more efficient if we call it again for the same term $t$ or a term in the same equivalence class.
\todo{cite}
\end{example}

We define the action $(+): \Z \rightarrow (\Z \times \T) \rightarrow (\Z \times \T)$, where $z_1 + (z_2,t) = (z_1 + z_2, t)$.
An equality $t_1 = z + t_2$ is satisfied by a partition $(\Pi, \tau, \omega)$, i.e., \find{t_1} = z + \find{t_2}, iff $t_1 \equivp z + t_2$.

\subsection{Quantitative finite automaton}

The union-find data structure is useful for representing equalities between atoms
with an addition of integer offsets.
The union operation needs to be modified in order to take into account also the dereferencing operation.
For example if $\T = {A, B, *A, *B}$ and we perform a union of $A$ and $B$, the
closure rule~\ref{item:dereferencing} tells us, that also the equivalence classes of $*A$ and $*B$ should be merged.
In order to efficiently find the equivalence class corresponding to the dereferenced terms of another equivalence class, we introduce the \emph{quantitative finite automaton} (QFA).

The QFA is defined by a triple $(S, \eta, \delta)$, where $S$ is a finite set of states, where each state represents an equivalence class from $\Pi$, $\eta : (\mathcal{A} \cup \{\&x | x \in \X\} \rightarrow \Z \times S)$ is a partial mapping that provides initial offsets and states for atoms, and $\delta : \Z \rightarrow S \rightarrow \Z \times S$ is the partial transition function.
Intuitively, if $\delta(z_1, s_1) = \delta(z_2, s_2)$, this means that for the representatives
$t_1, t_2$ of the equivalence class of $s_1,s_2$, resepectively, it holds that $*(z_1 + t_1) \equivp z_2 + t_2$.

The QFA is constructed from the partition  $(\Pi, \tau, \omega)$ by defining $M[\Psi,\T] = (S, \eta, \delta)$ where $S = \{s_i | Q_i \in \Pi\}$, $\eta a = (\omega a, s_i)$ if $a \in Q_i$ for some $Q_i \in \Pi$, and $\delta z s_i = (\omega t', s_j)$ if there is a $t' \in Q_j$ with $Q_j \in \Pi$, such that $t' = *(z_1 + t_1)$ with $t_1 \in Q_i$ and $z = z_1 + (\omega t_1)$.

We remark that a transition $\delta z s_i$ could derive not only from a single term $t'$ but also from a second term $*(z_2 + t_2) \in \T$ with $t_2 \in Q_i$ and $z = z_2 + (\omega t_2)$.
Since $t_i \equiv (\omega t_i) + (\tau Q_i)$ for $i = 1,2$, it follows that $t_1 \equiv (z_2 - z_1)+ t_2$. Therefore $*(z_2+t_2)\in Q_j$ with offset $\omega(*(z_2+t_2)) = \omega t'$.
This shows that the result of $\delta z s_i$ is well defined and doesn't depend on which term $t'$ we choose for deriving a transition.
Additionally, $\delta$ is defined only for a finite amount of values, given that each term $*(z + t) \in \T$ defines at most one mapping for $\delta$.

We use $\oT$ to denote the set of \emph{all} terms with variable names from $\X$ and auxiliaries from $\A$.
We can extend the mappings $\eta$,$\delta$ to a partial mapping $M : \oT \rightarrow \Z \times S$ where $M[a] = \eta(a)$ for atoms $a$, and $M[*(z+t_1)] = \delta(z+z_1, s)$ for terms $t_1$ if $M[t_1] = (z_1,s)$.

We define $M[\Psi] = M[\Psi,\T_\Psi]$, where $\T_\Psi$ is the set of terms and subterms occurring in $\Psi$.

We also define the set $\L(M)$ of terms $t \in \oT$ for which $M$ is defined.
For each state $s \in S$ we define the set $\L_M(s)$ of terms $t \in \oT$ for which it holds that $M[t] = (z, s)$ for some $z \in \Z$.

Using the automata, the \emph{closure}$(t_1,t_2,z)$ operation, which is the modified version of the union operation, is defined as follows:

\begin{enumerate}
  \item Case 1: $\tau\,t_1 = \tau\,t_2$. If $\omega\,t_1 = z + \omega\,t_2$ we are done.
  If $\omega\,t_1 \neq z + \omega\,t_2$, then the conjunctioin is unsatisfiable.
  \item Case 2: $\tau\,t_1 \neq \tau\,t_2$. We call \union{t_1}{t_2}{z}.
  Now either $t_1$ or $t_2$ has a new representative, so the transitions of the QFA are updated accordingly.
  Let $t$ be the term that has a new representative,
  and let $P = (\Pi, \tau, \omega)$ be the partition before the union operation and $P' = (\Pi', \tau', \omega')$ be the partition after the union operation.
  For each outgoing transition $\delta(z_1, s_1) = \delta(z_2, s_2)$ where $t \in \L(s_1)$,
  we set $\delta'(z_1 - \tau\,t'', s_1) = \delta'(z_2, s_2)$.
  \todo[inline]{Then use merge for the successors.}
  \todo{change $z_2$ in incoming transitions? how deep should I go in the details?}
\end{enumerate}

\todo[inline]{This is the same as congruence closure (cite) but restricted to a unary uninterpreted function symbol $*$ and extended with integer offsets as in (cite Oliveras Nieuwenhuis).}

\begin{theorem}
  % This is Theorem 3 in the other paper
  Assume that $\Psi$ is a satisfiable conjunction of equalities, let $\T$ be a subterm-closed set of terms which contains all terms occuring in $\Psi$.
  The corresponding quantitative partition $(\Pi, \tau,\omega)$ and a corresponding QFA $M = (S, \eta, \delta)$ are constructed by applying the closure operation to all equalities in $\Psi$.
  Then $\T \subseteq \L(M)$ and for every $t_1, t_2 \in \L(M)$ the following statements are equivalent:
  \begin{enumerate}
    \item $M[t_1] = z + M[t_2]$,
    \item $\Psi$ implies $(t_1 = z + t_2)$.
  \end{enumerate}
\end{theorem}

This theorem was proven in~\cite{2pointer} for the case of a one-dimensional memory model.
The proof can easily be adapted for the two-dimensional memory model.

We remark that the only equalities that can be derived from $\Psi$ are derived from $\Psi_=$. We cannot derive equalities from any of the disequalities.
