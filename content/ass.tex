\section{Assignment}

In the following, we will describe the abstract semantics $\sem{s_1\,{:=}\,s_2}^\sharp\,k$ of the assignment $s_1\,{:=}\,s_2$ over the kernel $k$, for each of the three possibilities of $s_2$.
If $k \equiv \bot$, then $\sem{s_1\,{:=}\,s_2}^\sharp\,k \equiv \bot$.
In the following, assume that $k \neq \bot$.

\subsection{Indefinite Assignment}

We consider an assignment of the form $s_1\,{:=}\,?$.
After this assignment, the value of $s_1$ changes to an unknown value,
so we must forget all the equalities and disequalities that contain the term $s_1$,
but also all other terms that may be modified by overwriting $s_1$.
Only the terms where we know that each subterm is definitely not equal to the address of $s_1$ and also definitely not overlapping with $s_1$ are not modified by overwriting $s_1$.

\begin{example}
	Consider the following C program:
\begin{minted}[linenos=true, escapeinside=||]{C}
int main(){
	long *lpt = (long *)malloc(sizeof(long));
	long lo = 0;

	*lpt = lo;// *lpt: 0; l: 0
	assert(*lpt == lo);|\label{firstassert}|
	*(lpt + 1) = 'a';// *lpt: 0; l: 0|\label{assignmentuno}|
	assert(*lpt == lo);|\label{secondassert}|
	*((char *)lpt + 1) = 'a';// *lpt: 24832; l: 0|\label{assignment}|
	assert(*lpt == lo); // this is false|\label{thirdassert}|
}
\end{minted}
In line~\ref{firstassert}, the assertion \texttt{*lpt == lo} holds, because the value of \texttt{*lpt} and the value of \texttt{lo} are both 0.
In line~\ref{assignmentuno}, the expression \texttt{*(lpt + 1)} is overwritten, which is represented as $*(64 + lpt)$ in our analysis.
We now want to determine if the term $*lpt$ is modified by this assignment.
The address of $*lpt$ is $lpt$ and the address of $*(64 + lpt)$ is $64 + lpt$.
Given that $lpt \nequiv_{k} 64 + lpt$, we know that the assignment does not write at the same address as $*lpt$, therefore we do not need to forget the information we had about $*lpt$.

However, in line~\ref{assignment}, the expression \texttt{*((char *)lpt + 1)} is overwritten, which is represented as $*(8 + lpt)$ in our analysis.
Even though we know that $lpt \nequiv_{k} 8 + lpt$, it does not hold that the value of $*lpt$ does not change when overwriting $*(8 + lpt)$, because the two values overlap.
Therefore, when a disequality between two terms follows from an equality with an offset, we additionally need to make sure that the terms do not overlap in order to be sure that assigning to one of them does not modify the other one.
\end{example}

Let $t_1$ be a pointer to a value that is $k_1$ bits large and $t_2$ be a pointer to a value of $k_2$ bits.
The two terms $t_1$ and $z + t_2$ overlap iff
\begin{itemize}
	\item $t_1 \equiv_{k} z' + t_2$ and
	\item $z' < 0$ and $-z' < k_1$, or $z' > 0$ and $z' < k_2$,
\end{itemize}\todo{add visualization?}
where $\equiv_{k}$ symbolizes the equalities that are implied by $k$, i.e.,
it is equal to $\equiv_{\F[k],\T}$.

In the following, we will describe how to find the set of terms
that are not modified by an assignment.
For this, we use different information sources: the disequalities implied by the abstract domain, the C-type of the terms to find potential overlaps, and the \emph{MayPointTo} analysis that is present in \goblint\ and which was introduced in \cref{section:goblint}.

Given a kernel $k = \angl{P, M, B, D}$, a partition $P = (\T, \tau, \omega)$ and a term $t$,
we want to compute the set $\restr{\T}{\neg t}$ that contains all terms $t' \in \T$ such that each subterm of $t'$ definitely does not alias or overlap with $t$.
This is exactly the set of terms that are not modified when the value of $t$ changes.
We differentiate between two cases: the case where $t$ is an atom and the case where $t$ is a dereferenced term.

If $t$ is an atom, then it is impossible to reach the address of $t$ by dereferencing.
Therefore, $\restr{\T}{\neg t}$ is the set of all terms that do not contain $t$ as a subterm.

If $t \equiv *(z + t')$ is a dereferenced term, then $\restr{\T}{\neg t}$ contains all the terms, where for each subterm of the form $*(z' + v)$ it holds that:
\begin{itemize}
	\item\label{item:diseqs} The disequality $v \nequiv_k (z - z') + t'$ is implied by $D$ or $B$;
    \item\label{item:eqs} or $t_1 \equiv_k z' + t_2$ for any $z' \neq z$ and the terms $v$ and $(z - z') + t'$ do not overlap. The C-type of the terms is used to determine the size in bits of the value that is stored at the address of the term;
    \item or the intersection of the sets of addresses that $v$ may point to and the addresses that $(z - z') + t'$ may point to is empty.
    These sets are computed using the \emph{MayPointTo} analysis of \goblint.
\end{itemize}

To simplify the notation, the restricted kernel $\restr{k}{\restr{\T}{\neg t}}$ is denoted $\restr{k}{\neg t}$.
It represents all propositions that follow from $k$ and that are still valid after overwriting the value of $t$.
The assignment is defined as follows:

\[
	\sem{s_1\,{:=}\;?}^\sharp\,k \equiv \restr{k}{\neg s_1}.
\]

\begin{proposition}\label{p:ass-unknown}
	For every kernel $k$ and assignment $s_1\,{:=}\,?$,
	\[
		\sem{s_1\,{:=}\,?}\,(\gamma\,k) \subseteq \gamma\,(\sem{s_1\,{:=}\,?}^\sharp\,k)
	\]
\end{proposition}

The proof of this proposition for the case of a one-dimensional memory model can be found in~\cite{2pointer}.
This proof can easily be adapted to the two-dimensional model.

\subsection{Definite Assignment}

We consider an assignment of the form $s_1\,{:=}\,z_1+s$.
As before, we need to forget all the equalities and disequalities about terms that may be modified by overwriting $s_1$.
After this, is not sufficient to simply add the equality $s_1 = z_1+s$ to the set of equalities,
because the term $z_1 + s$ may also be modified by the assignment. For example, when we assign $V\,{:=}\,1+V$, the equality $V = 1 + V$ would incorrectly lead to an unsatisfiable conjunction.
Therefore, we introduce a fresh auxiliary $A$ and first assign $A$ to the right-hand side of the assignment, then restrict the automaton, and then assign $s_1$ to $A$.
This way we can remember the original value of $z_1 + s$ trough the auxiliary $A$ and reconstruct the equalities that still hold after the assignment.

Thus, the abstract effect of the definite assignment is defined as follows:

\[
	\sem{s_1\,{:=}\,z_1+s}^\sharp\,k\;\equiv\;
	\restr{((s_1=A)\land\restr{((A=z_1+s)\land\Psi)}{\neg s_1})}{\neg A}
\]

\begin{proposition}\label{p:ass-definite}
	For every kernel $k$ and any assignment of the form $s_1\,{:=}\,z_1+s$,
	\[
		\sem{s_1\,{:=}\,z_1+s}\,(\gamma\,k) \subseteq \gamma\,(\sem{s_1\,{:=}\,z_1+s}^\sharp\,k)
	\]
\end{proposition}

As before, the proof of this proposition for the case of a one-dimensional memory model can be found in~\cite{2pointer}.

\subsection{Memory Allocation}

We consider an assignment of the form $s_1\,{:=}\,\malloc$.
The term $s_1$ is assigned to a fresh address, therefore we know that after the assignment,
the block of the term $s_1$ is different from the block of any other term in the set $\T$ of the partition,
but also different than any other term $t \in \oT$ that is not (yet) in the partition.
However, we cannot remember an infinite number of equalities that contain an infinite number of possible terms,
therefore we choose to only remember that this new address is different than the address of any other term in $\T$.
Let $k = \angl{P, M, B,D}$, and $\restr{k}{\neg s_1} = \angl{P', M', B', D'}$.
For each equivalence class in the partition $P'$, we add a disequality that states
that the block of the term $s_1$ is different from the block of the representative of the equivalence class.

\[
	\sem{s_1\,{:=}\,\text{\malloc}}^\sharp\,k \equiv
	\restr{k}{\neg s_1}\;\meet
	\bigwedge_{t\in \T, t \nequiv s_1}(bl(s_1) \neq bl(\tau\,t))
\]

\begin{proposition}\label{p:ass-malloc}
	For every kernel $k$ and any assignment of the form $s_1\,{:=}\,\malloc$,
	\[
		\sem{s_1\,{:=}\,\malloc}\,(\gamma\,k) \subseteq \gamma\,(\sem{s_1\,{:=}\,\malloc}^\sharp\,k)
	\]
\end{proposition}

\begin{proof}
	We only consider the case where $s_1$ equals the expression $*(z+t)$.
	The other case where $s_1 = V$ is analogous.
	Let $(\rho',\nu',\mu') \in \sem{s_1\,{:=}\,\malloc}\,(\gamma\,k)$, then we know that there exists $(\rho,\nu,\mu) \in \gamma\,k$ such that $\rho'=\rho$, $\nu'=\nu$ and $\mu' =\mu\oplus\{(z+\sem{t}\,(\rho,\nu,\mu))\mapsto (a,0))\}$ and $a$ is \emph{fresh}.
	From Proposition~\ref{p:ass-unknown} it follows that $(\rho',\nu',\mu') \models \restr{k}{\neg s_1}$.
	Given that $a$ is \emph{fresh}, it follows that all addresses stored in any term which is not $s_1$ do not have the same address block as $a$, therefore $(\rho',\nu',\mu') \models \bigwedge_{t\in \T, t \nequiv s_1}(bl(s_1) \neq bl(\tau\,t))$.
	It directly follows that $(\rho',\nu',\mu') \in \gamma\,(\sem{s_1\,{:=}\,\malloc}^\sharp\,k)$
\end{proof}
