\section{Equality}

Given two kernels $k_1$ and $k_2$, we want to decide whether they are semantically equivalent.
In this section, two methods for computing the \emph{equal} operation are presented.
Their main difference is in how the equivalence of two partitions $P_1$ and $P_2$ is decided.
The first method is based on comparing the equivalence classes of the partitions $P_1$ and $P_2$.
The second method is based on computing a normal form of the conjunctions represented by the kernels $k_1$ and $k_2$.
It then suffices to compare the normal forms syntactically. This has the advantage that the normal form can be computed once
for every kernel and there is no need to recompute it for every comparison.

\subsection{Comparing Equivalence Classes}

Let $P_1 = (\T_1, \tau_1, \omega_1)$ and $P_2 = (\T_2, \tau_2, \omega_2)$ be two partitions.
First, we extend both partitions to the set $\T = \T_1 \cup \T_2$.
Then we compare the equivalence classes of the resulting partitions $P_1' = (\T, \tau_1', \omega_1')$ and $P_2' = (\T, \tau_2', \omega_2')$ of $\ext{P_1}{\T}$ and $\ext{P_2}{\T}$.

For this, we need to check for each element $t \in \T$, if $t = \omega_1'\,t + \tau_1'\,t$ also holds in $P_2$, i.e.,
if $\omega_2'\,t + \tau_2'\,t = \omega_1'\,t + \omega_2'\,(\tau_1'\,t) + \tau_2'\,(\tau_1'\,t)$.

\subsection{Compute Normal Form}

In~\cite{2pointer} a different approach is presented to decide the equivalence of two partitions.
This is done by computing a normal form $\nf(\Psi)$ of a conjunction $\Psi$, such that $\Psi$ is semantically equivalent to $\nf(\Psi)$ and such that two conjunctions $\Psi_1$ and $\Psi_2$ are semantically equivalent iff $\nf(\Psi_1)$ and $\nf(\Psi_2)$ are syntactically equivalent.

The main idea is to find \emph{minimal representatives} for each state $s$ in the QFA $P_M$,
which corresponds to the smallest term in $\L(s)$, according to the order defined in \cref{chapter:2pointer}.
Then the automaton is transformed to a formula that utilizes only the minimal representatives, thus obtaining a normal form
that is independent on the chosen set $\T$ and on the chosen representatives.

Let $M_P = (S, \otau, \eta, \delta)$ be a QFA.\@
For each state $s \in S$, we compute the minimal term $m_s$ and the corresponding offset $z_s$ such that $M[m_s] = (z_s,s)$.
This can be computed by using a variantion of Dijktra's shortest path algorithm,
that will be described in the following.
We use an initially empty FIFO queue $P$ to store all states $s$ for which $(m_s,z_s)$ is already computed,
but where the outgoing edges still have to be processed.
First, we consider all atoms $a$ for which $\eta$ is defined, in ascending order. For each $\eta\,a = (z,s)$ we do:
\begin{enumerate}
    \item If $(m_s,z_s)$ is not defined yet, set $(m_s,z_s) = (a,z)$.
    \item Add $s$ to $P$.
\end{enumerate}
Then we process the queue $P$ in a FIFO manner, until it is empty.
For each state $s$ in $P$, we consider all outgoing edges $\delta\,z\,s = (z',s')$ in order of ascending $z$.
For each such edge, we do:
\begin{enumerate}
    \item If $(m_{s'},z_{s'})$ is not defined yet, set $(m_{s'},z_{s'}) = (*((z-z_s)+m_s),z')$.
    \item Add $s'$ to $P$.
\end{enumerate}
The algorithm is correct because longer pathss always result in lrger terms than shorter paths.
Thus, we do not need to update a pair once it was computed.

\begin{example}
\todo[inline]{TODO}
\end{example}
