\chapter{Concrete Semantics}\label{chapter:concrete_semantics}

This chapter will describe the model of concrete program states used in this thesis and its semantics during assignments and function calls.

The concrete state consists of the memory content and the values of the variables.
The memory is modeled as a two-dimensional address space $\ZZ$, where each address is a pair of a \emph{block identifier} and an \emph{offset} within the block.
Each call to \malloc\ returns an address with a fresh block identifier, and each variable is in a unique memory block of the memory, distinct from the block of any other variable.

We call \emph{auxiliaries} the variables whose address is never taken in the current program, therefore we know of these variables that their address cannot be reached from other terms using address arithmetic or dereferencing.
Let $\X$ and $\A$ be disjoint finite sets of non-auxiliary variables and auxiliaries.
A concrete state is composed of the following three functions:
\begin{itemize}
    \item $\rho : \X \rightarrow \ZZ$ assigns an address to each variable,
    \item $\nu : \mathcal{A} \rightarrow \ZZ$ assigns an address to each auxiliary, and
    \item $\mu : \ZZ \rightarrow \ZZ$ assigns a value to each address.
\end{itemize}
We are only interested in analyzing the values of pointers and addresses. Therefore, we interpret each value stored in the memory and the auxiliaries as an address.

In order to define the effects of program statements, we first need to describe the meaning of C expressions.
\cpo\ considers only expressions whose C type is a pointer type and which are equivalent to a term used in the 2-Pointer Logic~\cite{2pointer}.
This logic is the basis of the \cpo\ analysis and will be described in \cref{chapter:2pointer}.
The terms we consider are formed from auxiliaries and addresses of program variables, using constant offsets and dereferencing.
They are defined by the following grammar:
\[
    t\,{::=}\,A \mid \&x \mid *(z+t),
\]
where $A\in \A$ is an auxiliary, $x \in \X$ is a variable with address $\&x$ and $z \in \Z$ is an integer.
We call terms $\&x$ or $A$ \emph{atoms}.

A term $t$ in the C code is interpreted as the value $\sem{t}(\rho, \nu, \mu)$ defined by:
\[
    \begin{array}{lll}
        \sem{\& x}\,(\rho,\nu,\mu)   & = & \rho\,x,                          \\
        \sem{A}\,(\rho,\nu,\mu)      & = & \nu\,A,                           \\
        \sem{*(z+t)}\,(\rho,\nu,\mu) & = & \mu\,(z+\sem{t}\,(\rho,\nu,\mu)), \\
    \end{array}
\]
where the operator $(+) : \Z \rightarrow \ZZ \rightarrow \ZZ$ on addresses is defined as $z + (a,b) = (a, z+b)$.
Here, $z$ is added to the address offset, thus modeling that it is impossible to leave a memory block using address arithmetic.

\section{Assignment}

We consider assignments of the form $s_1\,{:=}\,s_2$ where $s_1$ is either an auxiliary $V \in \mathcal{A}$ or a pointer term $*(z+t)$, while $s_2$ is either the symbol $?$, which represents an unknown value, or is of the form $z_1 + t$ for some term $t$, or \malloc, which assigns an address from a fresh block to $s_1$.
A \emph{fresh} address block $a$ is an address block identifier that does not occur as a mapping in any of the functions $\rho$, $\nu$, or $\mu$, i.e., for each result $(a',b')$ of the functions $\rho$, $\nu$, or $\mu$, we have $a \neq a'$.

For a set $H$ of states $(\rho,\nu,\mu)$, we define the concrete semantics of the assignment
$s_1\,{:=}\,s_2$ as the transformation
$\sem{s_1\,{:=}\,s_2}\,H$, where:\todo{don't call it V}
\[
    \begin{array}{l}
        \sem{V\,{:=}\,?}\,H =
        \\
        \quad \{(\rho,\nu\oplus\{V\mapsto a\},\mu)\mid(\rho,\nu,\mu)\in H,a\in\ZZ\}                   \\
        \sem{*(z+t)\,{:=}\,?}\,H =                                                                    \\
        \quad \{(\rho,\nu,\mu\oplus\{(z+\sem{t}\,(\rho,\nu,\mu))\mapsto a\})
        \mid(\rho,\nu,\mu)\in H,a\in\ZZ\}                                                             \\
        \sem{V\,{:=}\,z_1+s}\,H =                                                                     \\
        \quad \{(\rho,\nu\oplus\{V\mapsto z_1+\sem{s}\,(\rho,\nu,\mu)\},\mu)\mid(\rho,\nu,\mu)\in H\} \\
        \sem{*(z+t)\,{:=}\,z_1+s}\,H =                                                                \\
        \quad \{(\rho,\nu,\mu\oplus\{(z+\sem{t}\,(\rho,\nu,\mu))\mapsto z_1+\sem{s}\,(\rho,\nu,\mu))\}
        \mid(\rho,\nu,\mu)\in H\}                                                                     \\
        \sem{V\,{:=}\,\malloc}\,H =                                                                   \\
        \quad \{(\rho,\nu\oplus\{V\mapsto (a,0)\},\mu)\mid
        (\rho,\nu,\mu)\in H, a\in \Z,
        a \text{ is a \emph{fresh}}\}                                                                 \\
        \sem{*(z+t)\,{:=}\,\malloc}\,H =
        \\
        \quad\{(\rho,\nu,\mu\oplus\{(z+\sem{t}\,(\rho,\nu,\mu))\mapsto (a,0))\}\mid
        (\rho,\nu,\mu)\in H, a\in \Z, a \text{ is a \emph{fresh}}\}.
    \end{array}
\]
Here,
$f\oplus\{m\mapsto z\}$ is the mapping obtained
from $f$ by
setting the value of $f$ for $m$ to $z$.

\section{Interprocedural Semantics}

Let $f$ be a function with parameters $p_1, \ldots, p_n$.
Assume that there is an edge of the CFG labeled $f(e_1, \ldots, e_n)$,
and the concrete state before the function call is $(\rho, \nu, \mu)$.
The initial state of the function call is defined by the function $\enter\,(\rho, \nu, \mu)$, which returns the state $(\rho', \nu', \mu')$, defined as follows:
\begin{itemize}
    \item $\rho'\,x = \rho\,x$ for all global variables $x \in \X$.
          For the caller's local variables, $\rho'$ is not defined.
          Additionally, for each parameter $p_i \in \X$ of the function, $\rho'\,p_i = \sem{e_i}$.
    \item $\nu'$ is defined correspondingly: it contains the entries of $\nu'\,A = \nu\,A$ for all global variables $A \in \A$, and it is not defined for the caller's local variables.
          For each auxiliary parameter $p_i \in \A$ of the function, $\nu'\,p_i=\sem{e_i}$.
    \item $\mu'\,(a,b)=\mu\,(a,b)$ for each address $(a,b)$.
\end{itemize}

At the end of the function, let the resulting state be $(\rho', \nu', \mu')$ and the caller state before the function call  $(\rho, \nu, \mu)$.
The concrete semantics of the edge returning from the function to the caller is defined by $\combine\,(\rho, \nu, \mu)\,(\rho', \nu', \mu')$, which returns the state $(\rho'', \nu'', \mu'')$:
\begin{itemize}
    \item $\rho''\,x = \rho'\,x$ for all global variables $x \in \X$ and $\rho''\,x = \rho\,x$ for the local variables of the caller.
          The local variables of the function are not defined in $\rho''$.
    \item Correspondingly, $\nu''\,A = \nu'\,A$ for all global auxiliary variables $A \in \X$ and $\nu''\,A = \nu\,A$ for the local variables of the caller, and $\nu''$ is not defined for the function's local variables.
    \item $\mu''\,(a,b)=\mu'\,(a,b)$ for each address $(a,b)$.
\end{itemize}

\todo{maybe say callee instead of function?}
