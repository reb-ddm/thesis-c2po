\chapter{Conclusion}\label{chapter:conclusion}

It this master's thesis, we designed and implemented a weakly-relational pointer analysis for C programs, called \cpo.
It is a static analysis based on abstract interpretation for C programs,
capable of inferring relational properties between pairs of pointer expressions that contain dereferences and pointer arithmetic.

The basic principles of abstract interpretation are presented, and then a concrete semantics is introduced that is the foundation for our abstract analysis.
Then, the 2-Pointer Logic~\cite{2pointer} is described, as well as its representation and operations for computing the closure of a conjunction of propositions and for changing the set of terms that are considered by the analysis.
The 2-Pointer logic can express equalities and disequalities between pairs pointer expressions that contain the addition of integer constants, as well as dereferences.
Here, it is extended with block disequalities, which model that pointer arithmetic is only valid within the same memory block.

The abstract domain of \cpo\ is represented by a representation of 2-Pointer Logic conjunctions, including a congruence closure of the equalities and representations of quantitative disequalities and block disequalities.

Operations for the analysis by abstract interpretation are described, including the \emph{equals}, \emph{meet}, \emph{join}, \emph{widening}, and \emph{narrowing} operations.
Two algorithms for the \emph{equals} and \emph{join} operations are presented, which differ in their precision and efficiency.
Transfer functions for assignments and dynamic memory allocation are defined.
For interprocedural analysis, the \emph{enter} and \emph{combine} functions are described.

The analysis was integrated into the static analyzer \goblint~\cite{goblint}.
The precision of the analysis was evaluated on 29 litmus tests and 11 real-world programs taken from the code for the GNU Core Utilities.
In order to evaluate the performance of the analysis, we ran the analysis on the SV-COMP 2024 benchmarks and compared the performance to the performance of \goblint\ without the \cpo\ analysis.

Our experiments demonstrate that our analysis scales reasonably for large programs and
that it infers some properties that the \goblint\ analyzer without \cpo\ was not able to infer.
The difference in precision and performance between the two algorithms for the \emph{join} operation and the two possibilities for the \emph{equals} operation is evaluated,
but no significant difference was found.
Therefore, the simpler algorithms are preferred for their easier implementation.

In order to improve the precision of the analysis and be able to infer more types of program behavior and possible undefined behavior, some future work is proposed in the next section.

\section{Future Work}

An interesting property that could be inferred by the analysis is the correct usage of mutexes.
For example, if a mutex is locked in one thread and it is unlocked in a different thread, then it is important to be sure that the unlocked mutex is still \emph{equal} to the locked mutex.
In order to prove this, the analysis must be extended to handle multi-threaded programs, by defining the behavior of the analysis when a thread is created and when shared memory is accessed.

Another possible extension is the explicit handling of undefined pointers.
A separate equivalence class could be added to the congruence closure that represents the set of all undefined pointers, i.e., those that are uninitialized or have been freed.
This extension would allow the analysis to detect invalid pointer accesses and double frees.
Additional closure rules must be added to express that an undefined pointer with a certain offset is still undefined, and that an undefined pointer is different from any other pointer, even other pointers in the same equivalence class.

Similarly, it could be investigated if it is useful to track null pointers.
As for the undefined pointers, a separate equivalence class for null pointers can be added.
This would allow the analysis to detect undefined behaviour relating to null-pointer dereferences.
