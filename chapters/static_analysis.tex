\chapter{Background}

The \cpo\ analysis described in this master's thesis is a static analysis that is based on abstract interprestation.
Before going into the details of the structure of the \cpo\ analysis,
it is useful to explain the key concepts of abstract interpretation and how it can be used
to design static program analyses.
This chapter also presents the \goblint\ abstract analyzer, where the \cpo\ analysis was implemented, and some of its analyzes that will later be
used by the \cpo\ analysis.

\section{Abstract Interpretation}

Abstract interpretation is a theoretical framework that is used to infer properties about programs
that are proven to be correct for all possible executions of the program.
It was first introduced by Patrick and Radhia Cousot in 1977~\cite{TODO} and is since then widely used
for program analysis and also other things. (TODO)
The analysis is done at compile-time (=statically), without having to execute the program.
This way it is also possible, for example, to prove the non-termination of a program.
The \cpo\ analysis described in this thesis, however, focuses on analyzing
relationships between pairs of pointer variables at each program point.

\subsection{Abstraction of the Concrete Semantics}

The analysis by abstract interpretation is constructed by replacing the concrete
semantics of a program with an abstract over-approximation of the program's behavior.
This abstract semantics is a simplified version of the concrete semantics
and can thus be computed in an efficient way.
Each step of the analysis needs to be proven proven to be a correct over-approximation of the concrete behaviour,
therefore the analysis is correct by construction.

The program is represented by a control flow graph (CFG), where each node represents a program point and each edge represents a statement of the program, such as assignments, conditional branches and function calls.
A concrete state of the program is defined by functions that describe the values for each variable and each memory address.
\cref{fig:example-C-program} shows an example C program and \cref{ex:cfg} shows its corresponding CFG.

\begin{figure}\begin{minipage}{0.45\textwidth}

\begin{minted}{C}
main(){
  int x = 1;
  x = x + 1;
}
\end{minted}

\end{minipage}
\begin{minipage}{0.45\textwidth}

  \begin{tikzpicture}[
    node distance=2cm,
    on grid,
    auto,
    state/.style={circle, draw, minimum size=2em, font=\small}
  ]

  \node[state, initial, initial text=main] (p1) {$p_1$};
  \node[state, below=of p1] (p2) {$p_2$};
  \node[state, accepting, below=of p2] (p3) {$p_3$};

  \path[->] (p1) edge node[right] {$x = 1$} (p2)
            (p2) edge node[right] {$x = x + 1$} (p3);

  \end{tikzpicture}
\end{minipage}

  \caption{An example of a C program and its corresponding CFG.}
\label{fig:example-C-program}

\end{figure}
\todo{make it a) and b) figure}

The concrete edge effect $\sem{l}$ describes the effect that an edge with label $l$ has on the concrete state.
For example in \cref{fig:example-C-program}, the concrete state at node $p_2$ is $s_{p_2} = \angl{x \rightarrow 1}$.
The state of node $p_3$ is equal to $\sem{x = x+1}\,s_{p_3} = \angl{x \rightarrow 2}$.

The abstract interpretation method consists in over-approximating the concrete semantics at each node in the CFG with an abstract description of the state.
Each analysis chooses an abstract domain that can characterize specific properties of interest of the program.
For a node $p$ in the CFG; the abstract state is denoted as $X[p]$.
For example, the abstract domain of the \cpo\ analysis is a conjunction of equalities between pointers.
At each program point one such conjunction is computed, that over-approximates all possible concrete states at that point.
Another simpler example would be an abstract domain that remembers for each variable if it is even or odd.
An abstract state that only contains the variable $x$ is represented as $\angl{x \rightarrow \text{even}}$, $\angl{x \rightarrow \text{odd}}$ or $\angl{x \rightarrow \text{unknown}}$ if the parity of $x$ is not known.

The abstract edge effect $\sem{l}^\sharp$ describes the effect that an edge with label $l$ has on the abstract state.
For example, in the CFG in \cref{fig:example-C-program}, the abstract state at node $p_2$ is $X[p_2] = \angl{x \rightarrow \text{odd}}$.
After the edge with label $x = x+1$, the abstract state at node $p_3$ is $\sem{x = x+1}^\sharp\,X[p_3] = \angl{x \rightarrow \text{even}}$.

The elements of the abstract domain must form a complete lattice, i.e., there is a partial order $\sqsubseteq$ between the elements and for each subset of elements there is a least upper bound (join, $\join$) and a greatest lower bound (meet, $\meet$).
Alternatively, if it is not possible to find the exact least upper bound, a sound over-approximation
can be used instead, without losing the correctness of the analysis.
A complete lattice also has a top element $\top$ and a bottom element $\bot$, which represent the least and greatest elements of the lattice, respectively.
During the analysis, the value $\top$ represents an abstract state that hold no information
about any variable, while $\bot$ represents a program point that is unreachable.

The concrete and the abstract semantics are related by the concretization function $\gamma$ and the abstraction function $\alpha$.
The concretization function maps an abstract element to the set of all concrete elements that are represented by the abstract element.
For example, the concretization of $\angl{x \rightarrow \text{even}}$ is the set of all concrete states where $x$ is an even number:
\[
\gamma(\angl{x \rightarrow \text{even}}) = \{\angl{x \rightarrow 0}, \angl{x \rightarrow 2}, \angl{x \rightarrow 4},\ldots\}
\]
The abstraction function maps a concrete element to the most precise abstract element that represent the concrete element. For example, $\alpha(\angl{x \rightarrow 0}) = \angl{x \rightarrow \text{even}}$.

The functions $\gamma$ and $\alpha$ form a Galois connection, that ensures the following property for each abstract state $a$ and each edge label $l$:
\[
\sem{l}\,\gamma(a) \subseteq \gamma(\sem{l}^\sharp\,a).
\]
This equality guarantees that the abstract edge effect of $l$ is an over-approximation
of the concrete edge effect.
Given that it holds for each $l$, we know that computing the semantics of a program in the abstract domain is a sound
over-approximation of the concrete semantics.

\subsection{Program Analysis}

The analysis of a program via abstract interpretation is done by traversing the CFG and computing the abstract state at each node.
We begin from the entry point of the \textsf{main} function in the CFG, which has the initial abstract state $\top$.
Then each edge is traversed and the abtract effects of the edges are applied to the abstract state.
If the abstract state at a node changes, the analysis must sometimes re-visit nodes multiple times.
The abtract effects of each type of edge is described in the following.

\subsubsection{Assignment}
The abstract effect of an assignment $\sem{x = e}^\sharp$ computes the change in the abstract state when assigning the expression $e$ to the variable $x$.
For example, if $x$ and $e$ are pointers, the \cpo\ analysis removes all old equalities that were talking about $x$, as the vaue of $x$ might have changed.
Then it adds the equality $x = e$ to the abstract state.
\subsubsection{Conditionals}
When there is an if statement with the condition $c$, the CFG is split into two branches, one for the true branch ($Pos(c)$) and one for the false branch ($Neg(c)$).
The analysis can compute the abstract state $a_c$ corresponding to the condition and
then meet the current abstract state $a$ with $a_c$, resulting in the state $a \meet a_c$.
The same can be done for the false branch with the abstract state corresponding to $\neg c$.
For example, if the condition is $x = y$, the \cpo\ analysis adds the equality $x = y$
in the positive branch and the disequality $x \neq y$ in the negative branch.
\subsubsection{Loops}
For-loops and while-loops add backwards edges in the CFG.
The abstract value of a program point that has multiple incoming edges is
the least upper bound of the set of all abstract states of the incoming edges.
Formally, the abstract state $X[p]$ of a node $p$ is defined as
\[
X[p] \sqsupseteq \bigsqcup \{\sem{l}^\sharp\,X[p'] \mid (p,l,p') \text{ is an edge from $p$ to $p'$ in the CFG labeled with $l$}\}.
\]

This generates an inequality for each program point.
According to the Knaster-Tarski theorem, each monotonic function $f$ on a complete lattice has a least fixpoint, which is equal to the least solution of the inequality $x \sqsubseteq f(x)$.
Therefore, the system of disequalities can be solved by starting with the bottom element $\bot$ for
each program point and iteratively applying the abstract semantics until a fixpoint is reached.
However, in some cases this approach does not converge.
This happens when the abstract domain has infinite ascending chains and the analysis
computes a sequence of states where each element is strictly greater than the previous one,
without reaching a fixpoint.

\subsubsection{Widening and Narrowing}

In order to ensure the termination of the analysis, a widening operator is used instead of the
join operator. It is applied during the iterations to compute the fixpoint of an inequality
in order to accelerate the computation and to ensure its termination, at the cost of losing a bit of the precision.
The widening operator $\widen$ over-approximates the join operator and it is designed in order to avoid infinite ascending chains.

Complementary to the widening, there is the narrowing operation, which is designed to
refine the result obtained by widening, thus restoring some of the precision that was lost by applying the widening.
The narrowing operation $\narrow$ over-approximates the meet operation in order to ensure that the fixpoint computation terminates.

\subsubsection{Interprocedural Analysis}

Abstract interpretation is also used to model function calls.
The concrete semantics of a function depends not only from the function definition, but also on the values of the parameters, global variables and the state of the memory at the time when the function is called.
Therefore, for each possible values that the parameters can have, a separate CFG is created.
An edge is added from the caller CFG to the entry point of the function, labeled with the $\enter$ function, and one from the entry point
of the function to the caller CFG, labeled with the $\combine$ function.
This is visualized in \cref{fig:function-cfg}.

\begin{figure}
  \begin{center}

\begin{tikzpicture}[
  node distance=1cm and 4cm,
  every node/.style={font=\small},
  call/.style={->, >=Stealth, thick, dashed, blue},
  combine/.style={->, >=Stealth, thick, dashed, red},
  block/.style={draw, circle,align=center}
]

% Nodes for main function
\node[block, initial, initial text=main] (start) {$p_0$};
\node[below=of start] (usw1) {...};
\node[block, below=of usw1] (beforecall) {$p_1$};
\node[block, below=of beforecall] (aftercall) {$p_2$};
\node[below=of aftercall] (usw2) {...};
\node[block, below=of usw2] (end) {$p_3$};

% Nodes for function f
\node[block, right=of usw1, initial right, initial text=f] (fstart) {$p_4$};
\node[below=of fstart] (usw3) {...};
\node[block, below=of usw3] (fend) {$p_5$};

% Edges for main function
\draw[->] (start) -- (usw1);
\draw[->] (usw1) -- (beforecall);
\draw[->] (beforecall) -- node[right] {f(...)} (aftercall);
\draw[->] (aftercall) -- (usw2);
\draw[->] (usw2) -- (end);

% Edges for function f
\draw[->] (fstart) -- (usw3);
\draw[->] (usw3) -- node[right] {return} (fend);

% Enter and combine edges
\draw[call] (beforecall.east) to node[above] {$\enter(s_{p_1})$} (fstart.west);
\draw[combine] (fend.west) to node[below] {$\combine(s_{p_1},s_{p_5})$} (aftercall.east);

\end{tikzpicture}


\end{center}
\caption{Visualization of the CFG of a program during a function call.}\label{fig:function-cfg}
\end{figure}


When traversing the edge from the function call of the caller to the entry point of the function, the $\enter$ function is called.
It has as parameter the state of the caller and it returns an initial state for the analysis of the function.
The concrete state returned by $\enter$ contains only global variables, the parameters and the local variables of the function.
The local variables of the caller are removed.
Then, each node in the CFG of the function is analyzed as usual,
starting from the initial state returned by $\enter$.

At the end of the function, the $\combine$ function is called when traversing the edge from the returning point of the function to the caller.
It takes as an argument the concrete state of the caller before having invoked the function,
and the final state of the function.
It keeps the information about the local variables of the caller and forgets the local variables of the function.
The values of the global variables and the content of the memory are equal to the state after the function call.

The abstract analysis of function calls are handled by the abstract enter function $\enter^\sharp$ and the abstract combine function $\combine^\sharp$.
As for the concrete semantics, the abstract CFG has an edge from the node before the function call to the entry point of the function and an edge from the exit point of the function to the node after the function call.
Let $s$ be the abstract state before the function call.
The start state of the function is $\enter^\sharp\,s$.
Each possible initial abstract value has a separate copy of the CFG of the function.
Let the final state of the function be $s'$.
The state after the function call is $\combine^\sharp\,(s,s')$.

\input{content/goblint}
