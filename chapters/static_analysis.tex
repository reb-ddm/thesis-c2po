\chapter{Background}\label{chapter:background}

The \cpo\ analysis described in this master's thesis is based on the abstract interpretation method.
Before going into the details of the structure of the \cpo\ analysis,
it is helpful to explain the fundamental concepts of abstract interpretation and how it can be used to design static program analyses.
This chapter also presents the \goblint\ abstract analyzer, where \cpo\ was implemented, as well as existing non-relational pointer analysis \emph{MayPointTo} and the analysis of tainted variables \emph{MayBeTainted}, which are implemented in \goblint.
They will later be used in collaboration with the \cpo\ analysis to increase precision.

\section{Abstract Interpretation}

Abstract interpretation is a theoretical framework used to infer the properties of programs that are proven to be correct for all possible executions of the program.
It was first introduced by Patrick and Radhia Cousot in 1977~\cite{ai,aibook}, and it has since been widely used in the fields of static analysis \cite{ai-static-analysis} and compiler construction \cite{ai-compiler-design}.
The analysis is performed at compile-time (i.e., statically) without requiring the program to be executed.
It consists in replacing the concrete
semantics of a program with an abstract over-approximation of the program's behavior.
This abstract semantics is a simplified version of the concrete semantics
and can thus be computed efficiently.
\ignore{This way, it is also possible, for example, to prove the non-termination of a program.
  The \cpo\ analysis described in this thesis, however, focuses on analyzing
  relationships between pairs of pointer variables at each program point.}

\subsection{Basic Principles}

\ignore{During the design of an abstract interpretation analysis,
  each step of the analysis is proven to be a correct over-approximation of the concrete behavior. Therefore, the result of the analysis is correct by construction.}

During the analysis, the program is represented by a control flow graph (CFG), where each node represents a program point, and each edge represents a statement of the program,
such as assignments, conditional branches, and function calls.
Each node $p$ in the CFG is associated with a concrete state $C[p]$ that describes the values of the variables and the memory at that program point.
\cref{fig:example-C-program} shows an example C program and \cref{fig:example-CFG} shows its corresponding CFG.

\begin{figure}\begin{subfigure}{0.45\textwidth}
\centering
    \begin{minted}{C}
int main(){
  int x = 1;
  x = x + 1;
}
\end{minted}
    \caption{A simple C program.}\label{fig:example-C-program}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[
        node distance=2cm,
        on grid,
        auto,
        state/.style={circle, draw, minimum size=2em, font=\small}
      ]

      \node[state, initial, initial text=main] (p1) {$p_1$};
      \node[state, below=of p1] (p2) {$p_2$};
      \node[state, accepting, below=of p2] (p3) {$p_3$};

      \path[->] (p1) edge node[right] {$x = 1$} (p2)
      (p2) edge node[right] {$x = x + 1$} (p3);

    \end{tikzpicture}
    \caption{A simple control flow graph.}\label{fig:example-CFG}
  \end{subfigure}

  \caption[An example of a control flow graph.]{An example of a C program and its corresponding CFG.}


\end{figure}

The concrete edge effect $\sem{l}$ describes the alteration of the concrete state after an edge with label $l$.
For example in \cref{fig:example-CFG}, the concrete state at node $p_2$ is $C[p_2] = \angl{x \rightarrow 1}$.
The state of node $p_3$ is equal to $C[p_3] = \sem{x = x+1}\,C[p_2] = \angl{x \rightarrow 2}$.

The abstract interpretation method consists of computing an abstract over-approximation of the concrete semantics at each node in the CFG with an abstract description of the state.
Each analysis chooses an abstract domain that can characterize specific properties of interest of the program.
For a node $p$ in the CFG, the abstract state is denoted as $X[p]$.
For example, the abstract domain of the \cpo\ analysis is a conjunction of equalities between pointers.
One conjunction is computed at each program point, over-approximating all possible concrete states.
Another simpler example would be an abstract domain that tracks whether each variable is even or odd.
An abstract state that only contains the variable $x$ is represented as $\angl{x \rightarrow \text{even}}$, $\angl{x \rightarrow \text{odd}}$,  or $\angl{x \rightarrow \text{unknown}}$ if the parity of $x$ is not known.

The abstract edge effect $\sem{l}^\sharp$ describes the effect that an edge with label $l$ has on the abstract state.
It must be an over-approximation of the corresponding concrete effect $\sem{l}$.
For example, in the CFG in \cref{fig:example-CFG}, the abstract state at node $p_2$ is $X[p_2] = \angl{x \rightarrow \text{odd}}$.
After the edge with label $x = x+1$, the abstract state at node $p_3$ is $X[p_3] = \sem{x = x+1}^\sharp\,X[p_2] = \angl{x \rightarrow \text{even}}$.

The elements of the abstract domain must create a complete lattice, meaning that there is a partial order denoted by $\sqsubseteq$ between the components, and for every subset of elements, there must be a least upper bound (or join, denoted by $\join$) and a greatest lower bound (or meet, denoted by $\meet$).
When it is impossible to find an exact computation of the meet or the join, a sound over-approximation can be used instead without losing the correctness of the analysis.
Complete lattices also have a top element ($\top$) and a bottom element ($\bot$), representing the lattice's least and greatest elements, respectively.
During the analysis, the value $\top$ represents an abstract state with no information about any variable, while $\bot$ represents an unreachable program point.

The concrete and the abstract semantics are related by the concretization function $\gamma$ and the abstraction function $\alpha$.
The concretization function maps an abstract element to the set of all concrete elements represented by the abstract element.
For example, the concretization of $\angl{x \rightarrow \text{even}}$ is the set of all concrete states where $x$ is an even number:
\[
  \gamma(\angl{x \rightarrow \text{even}}) = \{\angl{x \rightarrow 0}, \angl{x \rightarrow 2}, \angl{x \rightarrow 4},\ldots\}
\]
The abstraction function maps a concrete element to the most precise abstract element that represents the concrete element. For example, $\alpha(\angl{x \rightarrow 0}) = \angl{x \rightarrow \text{even}}$.

The functions $\gamma$ and $\alpha$ form a Galois connection, which ensures the following property for each abstract state $a$ and each edge label $l$:
\[
  \sem{l}\,\gamma(a) \subseteq \gamma(\sem{l}^\sharp\,a).
\]
This property guarantees that the abstract edge effect $\sem{l}^\sharp$ is an over-approximation
of the concrete edge effect $\sem{l}$.
If this property can be proven for each $l$, then we know that computing the semantics of a program in the abstract domain is a sound over-approximation of the concrete semantics.

\subsection{Abstract Effects of Program Statements}
The analysis of a program via abstract interpretation is done by traversing the CFG and computing the abstract state at each node.
We begin from the entry point of the \textsf{main} function in the CFG, which has the initial abstract state $\top$.
Then, each edge is traversed, and the abstract effects of the edges are applied to the abstract state.
The analysis must sometimes re-visit nodes multiple times when the abstract state of the predecessor of that node changes.
The abstract effects of each type of edge are described in the following.

\subsubsection{Assignment}
The abstract effect of an assignment $\sem{x = e}^\sharp$ computes the change in the abstract state when assigning the expression $e$ to the variable $x$.
For example, if $x$ and $e$ are pointers, the \cpo\ analysis removes all previous propositions involving $x$ since the value of $x$ might have changed.
Then, it adds the equality $x = e$ to the abstract state.
\subsubsection{Conditionals}
When there is an \textsf{if} statement with the condition $c$, the CFG is split into two branches, one for the \emph{true} branch (denoted by $Pos(c)$) and one for the \emph{false} branch (denoted by $Neg(c)$).
The analysis can compute the abstract state $a_c$ corresponding to the condition $c$ and then meet the previous abstract state $a$ with $a_c$, resulting in the state $a \meet a_c$.
The analysis does the same for the false branch with the abstract state corresponding to $\neg c$.
For example, if the condition is $x = y$, the \cpo\ analysis adds the equality $x = y$ in the positive branch and the disequality $x \neq y$ in the negative branch.
\subsubsection{Loops}
The CFG represents for-loops and while-loops as backward edges.
The abstract value of a program point with multiple incoming edges is
the least upper bound of the set of all abstract states of the incoming edges.
Formally, the abstract state $X[p]$ of a node $p$ is defined by the constraint
\[
  X[p] \sqsupseteq \bigsqcup \{\sem{l}^\sharp\,X[p] \mid \text{there is an edge from $p$ to $p'$ in the CFG labeled with $l$}\}.
\]
The abstract states are the solution of the system of constraints generated at each program point by this definition.
According to the Knaster-Tarski theorem, each monotonic function $f$ on a complete lattice has a least fixpoint, equal to the least solution of the inequality $x \sqsubseteq f(x)$.
Therefore, the system of inequalities can be solved by starting with the bottom element $\bot$ for each program point and iteratively applying the abstract semantics until the computation reaches a fixpoint.
However, in some cases, this approach does not converge.
This happens when the abstract domain has infinite ascending chains and the analysis computes a sequence of states where each element is strictly greater than the previous one, without reaching a fixpoint.

\subsubsection{Widening and Narrowing}

Sometimes, while traversing a loop, the analysis recomputes the abstract state of a program point infinitely many times without converging to a stable solution.
A widening operator ($\widen$) is used instead of the join operator in these cases.
The widening operator over-approximates the join operator, and it is designed to ensure the termination of the analysis of loops at the cost of some precision loss.

Complementary to the process of widening is the narrowing operation ($\narrow$), which is designed to refine the result obtained by widening in order to restore some of the precision lost by the widening operator.
The narrowing operation over-approximates the meet operation to partially regain the lost information by ensuring the termination of the computation.

\subsubsection{Interprocedural Analysis}

Before diving into the abstract effects of a function call, we discuss a concrete semantic for functions.
The concrete semantics of a function depends not only on the function definition but also on the values of the parameters, global variables, and the state of the memory at the time when the function is called.
Therefore, a separate CFG is created for each possible value that the parameters and memory can have.
An edge is added from the caller CFG to the function's entry point, labeled with the $\enter$ function, and one from the entry point
of the function to the caller CFG, labeled with the $\combine$ function.
These edges are visualized in \cref{fig:function-cfg}, where $p_4$ is the first node of the function, and $p_5$ is the final node.

\begin{figure}
  \centering
  \begin{tikzpicture}[
      node distance=1cm and 4cm,
      every node/.style={font=\small},
      call/.style={->, >=Stealth, thick, dashed, blue},
      combine/.style={>=Stealth, thick, dashed, red},
      block/.style={draw, circle,align=center}
    ]

    % Nodes for main function
    \node[block, initial, initial text=main()] (start) {$p_0$};
    \node[below=of start] (usw1) {...};
    \node[block, below=of usw1] (beforecall) {$p_1$};
    \node[block, below=of beforecall] (aftercall) {$p_2$};
    \node[below=of aftercall] (usw2) {...};
    \node[block, below=of usw2] (end) {$p_3$};

    % Nodes for function f
    \node[block, right=of usw1, initial right, initial text=f()] (fstart) {$p_4$};
    \node[below=of fstart] (usw3) {...};
    \node[block, below=of usw3] (fend) {$p_5$};

    % Edges for main function
    \draw[->] (start) -- (usw1);
    \draw[->] (usw1) -- (beforecall);
    \draw[->] (beforecall) -- node[right] {f(...)} (aftercall);
    \draw[->] (aftercall) -- (usw2);
    \draw[->] (usw2) -- (end);

    % Edges for function f
    \draw[->] (fstart) -- (usw3);
    \draw[->] (usw3) -- node[right] {return} (fend);

    % Enter and combine edges
    \draw[call] (beforecall.east) to node[above] {$\enter(C[p_1])$} (fstart.west);
    \draw[combine] (beforecall) ++(0,-1.1cm) .. controls +(right:1cm) and +(down:0.5cm) .. (aftercall.east);
    \draw[->, combine] (fend.west) to node[below] {$\combine(C[p_1],C[p_5])$} (aftercall.east);

  \end{tikzpicture}

  \caption[The CFG for a function call.]{Visualization of the CFG of a program during a function call.}\label{fig:function-cfg}
\end{figure}


When traversing the edge from the function call to the function's entry point, the $\enter$ function transforms the caller's concrete state to the initial state for the function analysis.
The concrete state returned by $\enter$ contains only global variables, the function parameters, and the function's local variables.
The caller's local variables are removed by $\enter$.
Then, each node in the CFG of the function is analyzed as usual,
starting from the initial state returned by $\enter$.

At the end of the function, the $\combine$ function merges the previous concrete state of the caller and the function's final state.
It is used when traversing the edge from the returning point of the function to the caller.
It keeps the information about the caller's local variables and forgets the function's local variables.
The values of the global variables and the memory content are equal to the state after the function call.

The abstract analysis of function calls is handled by the abstract enter function $\enter^\sharp$ and the abstract combine function $\combine^\sharp$.
They are an over-approximation of the corresponding concrete functions.
As for the concrete semantics, the abstract CFG has an edge from the node before the function call to the entry point of the function, labeled $\enter^\sharp$, and an edge from the exit point of the function to the node after the function call, labeled $\combine^\sharp$.

Let $s$ be the abstract state before the function call.
The start state of the function is $\enter^\sharp\,s$.
There is a copy of the function's CFG for each possible initial abstract value of the function.
Let the final state of the function be $s'$.
After the function call, the state is $\combine^\sharp\,(s,s')$.

\input{content/goblint}
